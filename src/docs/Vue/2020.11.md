# 2020.11.20

* v-model的本质
相当于v-bind 和 v-on

* .sync
对props实现双向绑定
~~~js
// 父组件中
<child :show.sync="valueChild" />
// 子组件中
this.$emit('update:show', false)
~~~

# 2020.11.21
1、v-if和v-show
v-if判断是否加载，可以减轻服务器的压力，在需要加载时加载，但有更高的切换开销，v-show调整DOM元素的CSS的display属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。
如果需要非常频繁地切换，则使用v-show较好，如果在运行时条件很少改变，则使用v-if较好

2、i18n 国际化
~~~js
const i18n = new VueI18n({
    locale: 'en', // 语言标识
    messages
})
// 通过切换语言标识来切换语言
~~~


# 2020.11.23
1、data为什么设置成函数
  组件中的`data`写成函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的`data`，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份`data`，就会相会干扰到。

2、computed & watch
计算属性computed:
- 支持缓存， 属性值也默认走缓存
- 不支持异步
- 属性可以相互依赖
- 属性值是函数，默认走get方法

侦听属性watch：
- 不支持缓存
- 支持异步
- 接收两个参数：最新值和旧值
- 监听数据必须是data中什么或者props中的，当数据变化时，触发其他操作，函数有两个参数。
  immediate： 组件加载立即触发回调函数。
  deep： 深度监听，为了实现对象内部值得变化，复杂类型得数据时使用，例如数组中得对象内容得改变，注意监听数组得变动不需要这么做。
      但是无法监听到数组得变动和对象的新增，参考vue数组变异，只有以响应式的方式触发才会被监听到。

当需要在数据变化时执行异步或开销较大的操作时，这个方法才最有用。
