# 垃圾回收算法
1、标记空间中的 可达 值
V8采用的是[可达性(reachability)算法]， 从根节点触发，遍历对象是否可达，来判断堆中的对象应不应该被回收。

2、回收 不可达 的值所占据的内存

3、做内存整理
[内存碎片] 回收后内存会有大量不连续的空间

# 何时垃圾回收
问题：回收垃圾时会暂停JS脚本，等垃圾回收完再继续执行。

# 分代收集
* 临时对象 -> V8 -> 新生代区域
* 长久对象 >- V8 -> 老生代区域

1、主垃圾回收器 -> 老生代
   对象占空间大，对象存活时间长
   [标记-清除]算法进行垃圾回收
2、副垃圾回收器
   通常只支持1-8M的容量  -> 对象区&空闲区
   新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾情理。
过程：对象区标记垃圾对象 -> 把活动数据加到空闲区  -> 两区对调 -> 满了就清。

**总结** 将堆分为新生代和老生代， 多回收新生代，少回收老生代

# 增量收集
引擎一次性遍历整个对象，会造成一个长时间暂停。 分成小块，每次处理一小部分，多次处理。

# 闲时收集
只会在CPU空闲时尝试运行。


问题一：浏览器怎么进行垃圾回收
1、什么是垃圾
+ 不再需要，即为垃圾
+ 全局变量随时可能用到的不一定是垃圾
2、如何捡垃圾
+ 标记可达
+ 回收不可达
+ 内存整理
3、什么时候捡垃圾
+ 垃圾回收造成页面卡顿
+ 分带、增量、闲时

问题二：不同类型变量的垃圾何时回收
+ 引用类型：没有引用时，通过V8自动回收
+ 基础类型
  - 闭包， 等闭包没有引用才会被V8回收
  - 非闭包，V8新生代切换的时候回收

问题三：内存泄漏？如何避免
+ 以Vue为例，通常有以下情况：
  - 监听的window/body等事件没有解绑
  - 绑在EventBUs事件没解绑
  - Vuex的$store, watch了之后没unwatch
  - 使用第三方库创建，没有调用正确的销毁函数
+ 解决办法：beforeDestroy中销毁
  - 绑定了DOM/BOM对象中的事件add -> remove
  - 观察者模式 $on, $off
  - 销毁定时器
  - 销毁第三方组件库
  - 使用弱引用weakMap， weakSet

+ 闭包会导致内存泄漏吗
不会。闭包变量仍然在使用，不是用不到的变量。  IE完成闭包后不会自动回收，IE的问题

问题四：weakMap weakSet和Map Set的区别
一旦不再需要，weakMap里面的键名对象和所对应的键值对会自动消失，不用手动删除。



